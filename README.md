# 밥밥밥 알고리즘 - 1일 1알고리즘 문제 풀기

### 1. 프로젝트 소개
#### 1.1. 개발배경 및 필요성
코딩 테스트는 취업 과정에서 필수적인 요소 중 하나입니다. 많은 기업들이 취업 시에 알고리즘 문제를 출제하며(일명 코딩테스트), 이를 통해 지원자들의 능력을 검증합니다. 따라서, 알고리즘 문제를 푸는 능력이 높은 학생들은 취업 시 경쟁 우위를 확보할 수 있습니다. 또한 면접에서 코딩테스트에서 푼 문제의 접근 방법이나 코드에 대해 설명하는 경우도 다수 있으므로 동아리에서 발표 및 토론을 통해 대비하고자 스터디를 진행하게 되었습니다.

컴퓨터공학 전공에서는 알고리즘 문제 해결 능력이 필요합니다. 과제나 시험에서 알고리즘 문제가 자주 출제되며 알고리즘 문제를 풀면서 학생들은 문제를 해결하는 과정에서 다양한 접근 방식을 연습하고, 문제를 해결하기 위한 논리적인 사고력을 기를 수 있습니다. 이를 통해 학생들은 문제 해결 능력을 향상시킬 수 있습니다.

학교 수업을 따라가는 것만으로는 알고리즘 능력을 기르는 데는 한계가 있기 때문에 목표가 같은 학생들이 모여 자발적으로 모여 문제를 해결하고 토론하며 그 능력을 기르고자 합니다.

#### 1.2. 개발 목표 및 주요 내용
- 백준 티어 한 단계 상승: 실버1 티어에서 골드5 티어로 올라가는 것을 구체적인 목표로 설정했습니다. 이를 통해 알고리즘 실력을 체계적으로 향상시키고, 더 어려운 문제에 도전할 수 있는 능력을 기릅니다.
- 발표 자료 30개 이상 작성: 알고리즘 문제 풀이에 대한 발표 자료를 노션 등을 활용해 체계적으로 정리하며, 스터디 참여자 간의 의견 교환과 피드백을 통해 깊이 있는 학습을 목표로 합니다.
- 깃허브에 30개 이상의 소스 코드 업로드: 모든 문제 풀이 코드를 깃허브에 올림으로써 자신만의 코드 관리 능력과 공유 문화를 학습하고, 다른 사람들의 코드를 분석하며 성장할 기회를 만듭니다.

#### 1.3. 세부내용
> 스터디 과정

  팀원 별로 프로그래밍 문제를 풀 수 있는 수준이 모두 다르기에, 각각 따로 수준에 맞는 문제를 풀기로 정했습니다.  
  책, 구글, 챗 GPT 등을 이용하여 부족한 알고리즘은 따로 정리하고, 어려웠던 문제 등은 노션에서 관리했습니다. 

> 스터디 진행 방법

 1. 지정 문제를 일주일간 푼다
   1. 문제 난이도: 일주일에 2~3문제
   2. 세미나 날짜: **매주 월요일 10시 반**
 2. 세미나 전까지 정성스럽게 발표를 준비하고 노션에 정리한다.
 3. **세미나**에서 각자 문제를 풀이하면서 의견을 교환한다.
    1. 발표 순서:  선착순  `1` `2` `2` + 사다리
    2. 풀이 방법, 이슈 공유 등 자유형식
 4. 다음 주 문제를 정한다
 
#### 1.4. 기존 서비스 대비 차별성
알고리즘 문제를 푸는 과정에서 학생들은 프로그래밍 언어를 활용하며, 코딩 능력을 향상시킬 수 있습니다. 특히, 문제를 해결하는 과정에서 최적화된 코드를 작성하는 연습을 하면서, 좀 더 효율적인 코드를 작성하는 방법을 습득할 수 있습니다.
 알고리즘 문제를 푸는 과정에서 학생들은 컴퓨터 과학 분야에서 중요한 개념들을 학습할 수 있습니다. 예를 들어, 분할 정복, 동적 계획법, 그리디 알고리즘 등 여러 알고리즘 기법들을 습득할 수 있을 것입니다.
 토론 및 발표활동을 통해 서로의 코드를 비교하고, 더 나은 코드 작성 방법을 공유할 수 있습니다. 또한, 다양한 풀이 방법을 비교하여 더 나은 문제 해결 방법을 찾을 수 있습니다. 이를 통해 학생들은 서로의 코드를 비교하고, 다양한 접근 방식을 배울 수 있으며 코드 리뷰를 통해 코드 품질을 향상시키는 효과도 있습니다.
 
#### 1.5. 사회적가치 도입 계획
- 오픈소스 기여 및 공유 문화 활성화
  스터디에서 작성된 알고리즘 풀이 자료나 코드를 오픈소스로 공개하여, 더 많은 사람들이 학습에 활용할 수 있도록 기여할 수 있습니다. 깃허브를 통한 코드 공유는 누구나 참여할 수 있는 학습 자원으로 활용되어, 기술 지식의 평등한 접근을 촉진할 것입니다.

### 2. 상세설계
#### 2.1. 시스템 구성도

Github와 노션 등을 통해서 알고리즘 풀이 및 세미나 내용을 정리합니다.
| Github PR 관리 | 풀이 기록 |
|--|--|
|![image](https://github.com/user-attachments/assets/b9318b7d-c7fa-4ca0-9448-5a9d05f5c9e3) |![image](https://github.com/user-attachments/assets/d82b03eb-4a81-4a66-982b-84ce1b2a59ad)  |


#### 2.1. 사용 기술
- 언어: cpp, c, sql
- 정리: 노션

### 3. 개발결과
#### 3.1. 전체시스템 흐름도

백준에서 프로그래밍 문제 해결 ➡️ 노션에 코드 및 풀이 내용 정리(시간 되면 알고리즘 설명도) ➡️ 세미나 발표 ➡️ 현재 Github 레포지토리에 소스코드 올리기

#### 3.2. 기능설명 
세미나 내용 중 C++에서 유용한 함수 등을 추천하며, 서로의 팁을 공유했습니다.

예시> 
```cpp
pair<int, int> p;
p = make_pair(1,2);
p = {1,2}; // improved

int a=p.first, b=p.second;
auto [x,y] = p; // improved
```


#### 3.3. 기능명세서
알고리즘 공부한 내용을 함께 공유했습니다.

예시> 
| 그리디 알고리즘 |BFS 정리|
|--|--|
|![image](https://github.com/user-attachments/assets/d0558c1c-cfa4-4629-ab10-5ba06ee3ec2e) |![image](https://github.com/user-attachments/assets/6b6b447e-5b6c-46a4-b315-391a3dbfa9bd)  |
| 분할 정복법 | 동적 계획법 |
| ![image](https://github.com/user-attachments/assets/dee6276a-de66-4d5e-b646-0476132018a4) | ![image](https://github.com/user-attachments/assets/eb851dd0-7437-46e0-9b1e-d54b757bee3e) |

#### 3.4. 디렉토리 구조
```
├───📁Jang-Wonseok
│   ├───boj_1114
│   ├───boj_1197
│   ├───boj_1202
│   ├───boj_1238
│   ├───boj_1509
│   ├───boj_1647
│   ├───boj_1655
│   ├───boj_1753
│   ├───boj_1766
│   ├───boj_1781
│   ├───boj_1806
│   └───boj_1865
├───📁Kwon-Naehyeon
├───📁Lim-Yehyeon
├───📁Nam-Woeunjung
└───📁notice
```

### 4. 설치 및 사용 방법
1. 레포지토리 복제하기
   `git clone https://github.com/2024-PNU-SW-StudyGroup/Group-23.git`
2. c, cpp, sql 등 환경 설정하기
3. 실행하기

### 5. 팀 소개
> 팀원 소개 & 구성원 별 역할 분담 & 간단한 연락처를 작성하세요.

|          [남원정](https://github.com/1jeongg)          |          [권내현](https://github.com/KwonNaeHyeon)          |          [임예현](https://github.com/Lim-Yehyeon)          |          [장원석](https://github.com/Cotidie)          |   
| :--------------------------------------------------------: | :-------------------------------------------------------: | :----------------------------------------------------: | :----------------------------------------------------: |
| <img src="https://github.com/1jeongg.png" width="100"> | <img src="https://github.com/KwonNaeHyeon.png" width="100"> | <img src="https://github.com/Lim-Yehyeon.png" width="100"> | <img src="https://github.com/Cotidie.png" width="100"> | 
|                           스터디 진행자                           |                            Github PR 관리                             |                       알고리즘 문제 선정                           |                           회의 시간 정리                           | 
|`leena0912@pusan.ac.kr` | `mojang1104@pusan.ac.kr` |`yh2269@naver.com` | `daily142857@gmail.com` |

### 6. 참여 후기

☺️ 권내현: 다양한 문제 유형을 풀어보면서 코딩테스트에서 자주 출제되는 문제 패턴과 풀이법을 익힐 수 있었던 점이 좋았습니다. 서로의 풀이 방식을 공유하고 피드백을 주고받는 과정에서 사고의 폭도 넓어진 것 같습니다. 앞으로도 이런 스터디에 꾸준히 참여하고 싶습니다.

🐶 남원정: 대학교 4학년으로 취업 준비와 병행하느라 바쁜 일정이었지만, 값진 시간이었던 것 같습니다. 스터디 덕분에 책임감이 생겨 꾸준히 문제를 풀 수 있었고, 마감 시간에 맞춰 준비하다 보니 시간 관리 능력도 향상되었습니다. 스터디원들과의 협업도 즐거웠고, 서로 격려하며 공부하는 분위기가 큰 힘이 되어 코딩테스트 또한 잘 볼 수 있었습니다.

😺 임예현: 처음에는 코딩테스트 준비가 막막했는데, 스터디를 통해 체계적으로 공부하는 방법을 배울 수 있었습니다. 매주 정해진 문제를 풀고 발표하면서 스스로 부족한 점도 깨닫고 실력을 키울 수 있었습니다. 다른 스터디원들의 효율적인 코드와 아이디어를 보면서 새로운 관점을 배우게 된 점이 좋았습니다.

🐹 장원석: 스터디 참여 전에는 혼자 공부하다가 어려운 문제를 만나면 쉽게 포기하곤 했는데, 이번 스터디 덕분에 끝까지 도전하는 습관이 생겼습니다. 알고리즘에 대해 이해하는 걸 도와준 팀원들의 친절한 설명 덕분에 기초부터 다시 다질 수 있었던 게 가장 기억에 남습니다.


### 7. 코딩테스트, 이제는 실전이다!

> A 기업(대기업) 코딩테스트 합격 후기
> - 보안을 위해서 기업명 및 구체적인 문제 설명, 코드는 공개하지 않았습니다.

<1번 문제>

**문제**: 속도 일정 값만큼 올리고 내려서, 구간 통과하는 최소시간 구하기

**시간복잡도**: O(루트 n)

**접근 방식**: 수학(수열)

**구현방식**:

주어진 테스트케이스인 n=10일 때를 생각해봤을 때, 속도가 1, 2, 3, 2, 1 이렇게 규칙적인 수열이 되는 것을 보고, 수학적인 규칙성이 있을 것 같다고 생각했습니다.

규칙성을 파악하기 위해 k=1, 2일 때 각 테스트케이스별 정답을 n ≤ 20 일 때까지 계산했습니다.

그 결과, 답이 변화하는 지점이 2군데로 추려졌습니다. 첫 번째는1+2+3+4+3+2+1와 같이 최고 속도가 1번이고 연속되는 속도가 없는 지점, 즉 속도변화가 삼각형 형태인 유형이었습니다. 두 번째는 1+2+3+3+2+1 와 같이 최고 속도가 2번 연속으로 나오는 지점으로, 속도 변화가 사다리꼴 형태인 유형이었습니다.. 첫 번째와 두 번째 경우 속도의 전체 합을 각각 수식으로 나타내면 k*n*n와  k*n*(n+1)로 표현할 수 있습니다.

i=1부터 루트 n까지 반복문을 통해 대입하여 첫 번째와 두 번째 수식을 계산 큰 값이 나오면 멈춥니다. 이때 그 전까지 첫 번째와 두 번째 지점을 만족한 개수가 정답이 됩니다.

k=1일 때 예시
| 이동거리 | 답 | 속도변화 |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 1 | 1 |
| 2 | 2 | 1+1 |
| 3 | 3 | 1+1+1 |
| 4 | 3 | 1+2+1 |
| 5 | 4 | 1+1+2+1 |
| 6 | 4 | 1+2+2+1 |
| 7 | 5 | 1+1+2+2+1 |
| 8 | 5 | 1+2+2+2+1 |
| 9 | 5 | 1+2+3+2+1 |
| 10 | 6 | 1+1+2+3+2+1 |
| 11 | 6 | 1+2+2+3+2+1 |
| 12 | 6 | 1+2+3+3+2+1 |
| 13 | 7 | 1+1+2+3+3+2+1 |
| 14 | 7 | 1+2+2+3+3+2+1 |
| 15 | 7 | 1+2+3+3+3+2+1 |
| 16 | 7 | 1+2+3+4+3+2+1 |
| 17 | 8 | 1+1+2+3+4+3+2+1 |
| 18 | 8 | 1+2+2+3+4+3+2+1 |
| 19 | 8 | 1+2+3+3+4+3+2+1 |
| 20 | 8 | 1+2+3+4+4+3+2+1 |

k=2일 때 예시
| 이동거리 | 답 | 속도변화 |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 1 | 1 |
| 2 | 1 | 2 |
| 3 | 2 | 2+1 |
| 4 | 2 | 2+2 |
| 5 | 3 | 1+2+2 |
| 6 | 3 | 2+2+2 |
| 7 | 3 | 2+3+2 |
| 8 | 3 | 2+4+2 |
| 9 | 4 | 1+2+4+2 |
| 10 | 4 | 2+2+4+2 |
| 11 | 4 | 2+3+4+2 |
| 12 | 4 | 2+4+4+2 |
| 13 | 5 | 1+2+4+4+2 |
| 14 | 5 | 2+2+4+4+2 |
| 15 | 5 | 2+3+4+4+2 |
| 16 | 5 | 2+4+4+4+2 |
| 17 | 5 | 2+4+5+4+2 |
| 18 | 5 | 2+4+6+4+2 |
| 19 | 6 | 1+2+4+6+4+2 |
| 20 | 6 | 2+2+4+6+4+2 |

<2번 문제>

**문제**: 1, 1, 1에서 시작해 N, M, L로 이동했을 때 최댓값, 벽은 T번 지날 수 있음

**시간복잡도**: O(N*M*L)

**접근 방식**: BFS

**구현방식**:

BFS를 사용해서 해결할 수 있습니다. (1, 1, 1)에서 (N, M, L) 까지 도착할 때까지 아이템의 최대값을 구해야 하기 때문에, 깊이 우선 탐색보다는 넓이 우선 탐색의 특성을 활용하기 위해 BFS를 사용했습니다. 임의의 지점에서 벽을 동일한 횟수로 통과했을 때 다음 도착지 간 값을 비교하여 최댓값을 갱신합니다. 이때 시간 복잡도를 줄이고, 무한 반복이 되는 경우를 방지하기 위해 3차원 내용에 벽을 통과한 횟수를 추가하여 4차원 배열인 visit에 최댓값을 갱신했습니다.

> 2번 문제는 실제로는 풀지 못하고 제출했습니다.  
> 그래도 코딩테스트는 합격했습니다.







